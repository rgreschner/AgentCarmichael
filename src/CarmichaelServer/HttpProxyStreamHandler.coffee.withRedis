EventEmitter = require('events').EventEmitter
express = require('express')
uuid = require('node-uuid')
require('bufferjs/add-chunk')

class ProxyRequestPrepareInputNode extends BaseProcessingNode
  constructor: () ->
    super()
  process: (inputArgs) ->

    req = inputArgs.req
    id = uuid.v4().toString()

    console.log "Assigned id %s to request.", id

    req.id = id
    parsedUrl = require("url").parse(inputArgs.req.url)
    req.parsedUrl = parsedUrl

    inputArgs.req = req
    console.log "ProxyRequestInputNode finished processing."

    @finishedProcessing inputArgs
    return

class ProxyRequestFilterInputNode extends BaseProcessingNode
  constructor: () ->
    super()
  process: (inputArgs) ->
    console.log "Filtering..."
    @finishedProcessing inputArgs
    return

class HttpProxyStreamHandler extends BaseStreamHandler
  # Public ctor.
  #
  # @parrams args [Object] Costructor arguments.
  #
  constructor: (args) ->
    super(args)
    #@redisClient = args.redisClient
    @abc = new ExpressInternalRequestProcessingNode { 
      app : new MyExpressApp().app
    }
    inputNodes = [
      new ProxyRequestPrepareInputNode(),
      new ProxyRequestFilterInputNode()
    ]
    for i in [0..inputNodes.length-2]
      inputNodes[i].setOutputNode inputNodes[i+1]
    lastInputNode = inputNodes[inputNodes.length-1]
    @firstInputNode = inputNodes[0]
    lastInputNode.on 'finished', (outputArgs) =>
      if true == outputArgs.aborted
        console.log "Aborted processing."
        return
      @proxyRetrieveResource outputArgs.req
      return



  # Start stream handling.
  #
  handle: () ->
    @stream.on 'error', (error) =>
      console.log error
    @stream.on 'data', (chunk) =>
      @handleData chunk
    return 
  onParserGotUrl: (hp, buf, start, len) ->
    str = buf.toString('ascii', start, start + len)

    if hp.data.url
      hp.data.url += str
    else
      hp.data.url = str
  # Get handler type as string.
  #
  # @returns [String] Type of handler as string.
  #
  getHandlerType: () ->
    return "http_proxy"
  onParserGotHeaderField: (hp, buf, start, len) ->
    if hp.data.partial.value
      hp.data.headers[hp.data.partial.field] = hp.data.partial.value;
      hp.data.partial = {
        'field' : '',
        'value' : ''
      }
      hp.data.partial.field += buf.toString('ascii', start, start + len).toLowerCase();
  createHttpResponseForRequest: (proxiedReq, stream) ->
    res = new http.ServerResponse proxiedReq
    res.headers = []
    stream._httpMessage = res
    res.connection = stream
    res.writable = true
    res._writeRaw = (chunk, encoding) =>
      try
        stream.write(chunk, encoding)
      catch error
      return
    return res
  # Set HTTP client options to accomplish
  # proxy chaining.
  #
  # @param options [Object] Options of HTTP client.
  #
  setProxyChainingOptions: (options) ->

    # Set default port to 80.
    if (undefined == options.port)
      options.port = null
    if (null == options.port)
      options.port = 80

    oldHost = options.host
    newPath = "http://" + options.host
    if '/' != options.path
      newPath = newPath + options.path
    options.path = newPath
    options.host = "localhost"
    options.port = 8118
    options.headers['Host'] = oldHost
	
	# IP F*ck clone
    #options.headers['X-FORWARDED-FOR'] = '127.0.0.1'
    #options.headers['VIA'] = '127.0.0.1'
    #options.headers['CLIENT-IP'] = '127.0.0.1'
    return
  # Retrieve actual resource.
  #
  # @param proxiedReq [Object] Proxied request.
  #
  proxyRetrieveResource: (proxiedReq) ->

    # Set dummy members and methods on proxiedReq
    # to be compatible to normal HTTP request.
    proxiedReq.socket = {}
    proxiedReq.socket.destroy = () ->

    proxiedReqUrl = proxiedReq.parsedUrl

    stream = @stream
    res = @createHttpResponseForRequest proxiedReq, stream

    console.log "Host is " + proxiedReqUrl.host
    if "127.0.0.42" == proxiedReqUrl.host
      console.log "In local mode"

      inputArgs = {
        req : proxiedReq,
        res: res
      }
      @abc.once 'finished', (outputArgs) ->
        console.log outputArgs
        # Actually end request.
        outputArgs.res.end()

        return
      @abc.process inputArgs
      
      return
    
    if null != @redisClient
      @redisClient.get proxiedReq.parsedUrl.href, (err, result) =>
        if null == err && null != result
          res.write new Buffer(result, 'base64')
          res.end()
        else
          @proxyRetrieveResourceFromHttp proxiedReq, res
    else  
      @proxyRetrieveResourceFromHttp proxiedReq, res

  proxyRetrieveResourceFromHttp: (proxiedReq, res) ->
    options = proxiedReq.parsedUrl
    options = { 
      host: options.host,
      port: options.port, 
      path: options.path
    }
    

    
    options.method = 'GET'
    options.headers = {
      "Connection":"close"
    }

    # IP F*ck clone.
    #proxiedReq.headers['X-FORWARDED-FOR'] = '127.0.0.1'
    #proxiedReq.headers['VIA'] = '127.0.0.1'
    #proxiedReq.headers['CLIENT-IP'] = '127.0.0.1'

    # Proxy chaining
    @setProxyChainingOptions options


    console.log options

    http.get options, (remoteRes) =>
      @onHttpClientRequestFetchComplete proxiedReq, remoteRes, res
      return
    return

   
  # Callback for when HTTP client finished fetch of
  # HTTP request.
  #
  # @param remoteRes [Object] HTTP response from server.
  # @param res [Object] HTTP response for client.
  #
  onHttpClientRequestFetchComplete: (proxiedReq, remoteRes, res) =>
    remoteRes.useChunkedEncodingByDefault = false
    buffered = []


    console.log "Got response"
      
    contentType = remoteRes.headers['content-type']
    contentLength = undefined
    res.headers['content-type'] = contentType

    if (undefined != remoteRes.headers['content-length'])
      contentLength = remoteRes.headers['content-length'];
    if (undefined != contentLength)
      res.headers['content-length'] = contentLength
    statusCode = remoteRes.statusCode
    res.setHeader('X-AgentCarmichael', 'beta');
    res.statusCode = statusCode
    if 300 <= statusCode && 399 >= statusCode
      console.log "Redirect..."
      location = remoteRes.headers['location']
      console.log "Redirect location is "+location
      res.setHeader('Location', location)
      res.location = location

    remoteRes.on 'data', (chunk) =>
      res.write(chunk)
      if null != @redisClient
        @redisClient.get proxiedReq.parsedUrl.href, (err, result) =>
          cacheBuffer = chunk
          if null != err && null != result
            cacheBuffer = new Buffer(result,'base64').addChunk(chunk)
          @redisClient.set proxiedReq.parsedUrl.href, cacheBuffer.toString('base64')

    remoteRes.on 'end', () =>
        
      console.log("Request stream ended, status is "+statusCode+", content-length "+contentLength + ", content-type "+contentType);
      res.end()

  # Callback when parser finished parsing
  # of HTTP request's headers.
  #
  # @param info [Object] Parsed HTTP request.
  #
  onParserHeadersComplete: (req) ->
    
    inputArgs = {
      req: req
    }

    @firstInputNode.process inputArgs
      
    return

       
  # Create HTTP request parser.
  #
  # @returns [Object] HTTP request parser.
  #
  createRequestParser: () ->
    stream = @stream
    hp = new HTTPParser 'request'
    hp.data = {
      'headers' : {},
      'partial' : {
        'field' : '',
        'value' : ''
      }
    }

    hp.onURL = (buf, start, len) =>
      @onParserGotUrl hp, buf, start, len
      return
  
    hp.onHeaderField = (buf, start, len) =>
      @onParserGotHeaderField hp, buf, start, len
      return

    hp.onHeaderValue = (buf, start, len) =>
      hp.data.partial.value += buf.toString('ascii', start, start + len).toLowerCase()

    hp.onHeadersComplete = (req) =>
      @onParserHeadersComplete req


    return hp
  # Handle data of incoming HTTP request.
  #
  # @param chunk [Buffer] Raw data of HTTP request.
  #
  handleData: (chunk) ->
    if null == chunk
      console.log "Chunk is null."
      return
    buffer = new Buffer chunk
	
    @hp = @createRequestParser()
    @hp.execute buffer, 0, buffer.length


    return
